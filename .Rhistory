generateSeries(data, "start", "end")
data <- data.frame(start = c(1, 4), end = c(3, 6))
generateSeries(data, "start", "end")
#'
#' @examples
#' # Generate a numeric series
#' data <- data.frame(start = c(1, 4), end = c(3, 6))
#' generateSeries(data, "start", "end")
#'
#' # Generate a date-based series
#' data <- data.frame(start = as.Date(c("2021-01-01", "2021-02-01")),
#' end = as.Date(c("2021-01-05", "2021-02-05")))
#' generateSeries(data, "start", "end")
generateSeries <- function(input.df, start, end, step = 1, timeint = "day",
varname = "series") {
# Input validation
if (missing(input.df) || is.null(input.df)) {
stop("Argument 'input.df' is required and cannot be NULL")
}
if (missing(start) || missing(end)) {
stop("Both 'start' and 'end' column names must be provided")
}
if (!is.character(start) || !is.character(end) || !is.character(varname)) {
stop("Column names must be character strings")
}
if (length(start) != 1 || length(end) != 1 || length(varname) != 1) {
stop("Column names must be single values")
}
# Convert to data frame and validate structure
input.df <- tryCatch(
as.data.frame(input.df),
error = function(e) stop("Cannot convert input to data frame: ", e$message)
)
if (nrow(input.df) == 0) {
warning("Input data frame is empty")
return(data.frame())
}
# Check if columns exist
if (!start %in% names(input.df)) {
stop("Start column '", start, "' not found in input.df")
}
if (!end %in% names(input.df)) {
stop("End column '", end, "' not found in input.df")
}
if (varname %in% names(input.df)) {
warning("Output column '", varname, "' already exists and will be overwritten")
}
# Validate step parameter
if (!is.numeric(step) || length(step) != 1 || step <= 0) {
stop("Step must be a positive numeric value")
}
# Validate timeint parameter
valid_timeints <- c("sec", "min", "hour", "day", "week", "month", "quarter", "year")
if (!timeint %in% valid_timeints) {
stop("timeint must be one of: ", paste(valid_timeints, collapse = ", "))
}
# Check for missing values
if (any(is.na(input.df[, start]))) {
stop("Start column contains missing values")
}
if (any(is.na(input.df[, end]))) {
stop("End column contains missing values")
}
# Determine if we're working with dates
start.is.date <- inherits(input.df[, start], "Date")
end.is.date <- inherits(input.df[, end], "Date")
# Check for consistent data types
if (start.is.date != end.is.date) {
stop("Start and end columns must have the same data type (both Date or both numeric)")
}
is.date <- start.is.date && end.is.date
# Validate numeric columns if not dates
if (!is.date) {
if (!is.numeric(input.df[, start]) || !is.numeric(input.df[, end])) {
stop("Non-date columns must be numeric")
}
}
# Check for valid ranges (end >= start)
invalid.ranges <- if (is.date) {
input.df[, end] < input.df[, start]
} else {
input.df[, end] < input.df[, start]
}
if (any(invalid.ranges)) {
warning("Some end values are less than start values; these will produce empty sequences")
}
# Prepare step parameter
if (is.date) {
step <- paste(step, timeint)
}
# Generate sequences with error handling
seq.out <- tryCatch({
Map(seq, input.df[, start], input.df[, end], step)
}, error = function(e) {
stop("Error generating sequences: ", e$message)
})
# Calculate sequence lengths
seq.lengths <- sapply(seq.out, length)
# Check for empty sequences
if (all(seq.lengths == 0)) {
warning("All sequences are empty; returning empty data frame")
return(data.frame())
}
# Replicate original data to match sequence lengths
output.df <- tryCatch({
as.data.frame(lapply(input.df, rep, seq.lengths))
}, error = function(e) {
stop("Error replicating data: ", e$message)
})
# Add the generated series column
output.df$var <- if (is.date) {
tryCatch({
as.Date(unlist(seq.out), origin = "1970-01-01")
}, error = function(e) {
stop("Error converting date sequences: ", e$message)
})
} else {
unlist(seq.out)
}
# Rename the series column
names(output.df)[which(names(output.df) == "var")] <- varname
# Remove original start and end columns and return
cols.to.keep <- !names(output.df) %in% c(start, end)
result.df <- output.df[, cols.to.keep, drop = FALSE]
return(result.df)
}
data <- data.frame(start = c(1, 4), end = c(3, 6))
generateSeries(data, "start", "end")
generateSeries(data, "start", "end")
data <- data.frame(start = as.Date(c("2021-01-01", "2021-02-01")),
end = as.Date(c("2021-01-05", "2021-02-05")))
generateSeries(data, "start", "end")
data$id <- "A"
generateSeries(data, "start", "end")
#' # With axis titles enabled
#' ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) +
#'   geom_point() +
#'   labs(x = "Miles per Gallon", y = "Horsepower", color = "Cylinders") +
#'   addCraTheme(axis.titles = TRUE)
#'
#' # Without grid lines for cleaner look
#' ggplot(mtcars, aes(x = factor(cyl), fill = factor(cyl))) +
#'   geom_bar() +
#'   addCraTheme(grid.lines = FALSE, legend.position = "none")
addCraTheme <- function(base.size = 11, base.family = "", legend.position = "bottom",
grid.lines = TRUE, axis.titles = FALSE) {
# Input validation
if (!is.numeric(base.size) || length(base.size) != 1 || base.size <= 0) {
stop("Argument 'base.size' must be a single positive number")
}
if (!is.character(base.family) || length(base.family) != 1) {
stop("Argument 'base.family' must be a single character string")
}
valid.positions <- c("bottom", "top", "left", "right", "none")
if (!legend.position %in% valid.positions) {
stop("Argument 'legend.position' must be one of: ", paste(valid.positions, collapse = ", "))
}
if (!is.logical(grid.lines) || length(grid.lines) != 1) {
stop("Argument 'grid.lines' must be a single logical value")
}
if (!is.logical(axis.titles) || length(axis.titles) != 1) {
stop("Argument 'axis.titles' must be a single logical value")
}
# Base theme
base.theme <- theme_minimal(base_size = base.size, base_family = base.family)
# Custom theme elements
custom.theme <- theme(
# Legend styling
legend.position = legend.position,
legend.key.size = unit(0.4, "cm"),
legend.key.width = unit(0.5, "cm"),
legend.spacing.x = unit(0.2, "cm"),
legend.spacing.y = unit(0.1, "cm"),
legend.margin = margin(t = 0.3, unit = "cm"),
legend.title = element_text(size = rel(0.9), face = "bold"),
legend.text = element_text(size = rel(0.8)),
# Axis styling
axis.title = if (axis.titles) element_text(size = rel(0.9), face = "bold") else element_blank(),
axis.text = element_text(size = rel(0.8), color = "grey30"),
axis.ticks = element_line(color = "grey80", size = 0.3),
axis.ticks.length = unit(0.15, "cm"),
# Panel styling
panel.border = element_rect(color = "grey90", fill = NA, size = 0.5),
panel.grid.major = if (grid.lines) element_line(color = "grey95", size = 0.3) else element_blank(),
panel.grid.minor = if (grid.lines) element_line(color = "grey98", size = 0.2) else element_blank(),
# Plot styling
plot.title = element_text(size = rel(1.2), face = "bold", hjust = 0,
margin = margin(b = 0.5, unit = "cm")),
plot.subtitle = element_text(size = rel(1.0), color = "grey40", hjust = 0,
margin = margin(b = 0.3, unit = "cm")),
plot.caption = element_text(size = rel(0.7), color = "grey50", hjust = 1,
margin = margin(t = 0.3, unit = "cm")),
plot.margin = margin(t = 0.5, r = 0.5, b = 0.5, l = 0.5, unit = "cm"),
# Strip text for faceted plots
strip.text = element_text(size = rel(0.9), face = "bold",
margin = margin(0.3, 0.3, 0.3, 0.3, unit = "cm")),
strip.background = element_rect(fill = "grey95", color = "grey90", size = 0.3)
)
return(base.theme + custom.theme)
}
# Basic usage
ggplot(mtcars, aes(x = mpg, y = hp)) +
geom_point() +
addCraTheme()
library(tidyverse)
# Basic usage
ggplot(mtcars, aes(x = mpg, y = hp)) +
geom_point() +
addCraTheme()
#' Add Project-Specific ggplot Theme
#'
#' This function applies a custom ggplot2 theme with clean, minimal styling
#' suitable for professional reports and presentations. It builds on theme_minimal()
#' with customized legend positioning, axis styling, and improved readability.
#'
#' @param base.size Base font size for all text elements (default: 11).
#' @param base.family Base font family for all text elements (default: "").
#' @param legend.position Position of the legend: "bottom", "top", "left", "right", or "none" (default: "bottom").
#' @param grid.lines Logical indicating whether to show grid lines (default: TRUE).
#' @param axis.titles Logical indicating whether to show axis titles (default: FALSE).
#'
#' @return A ggplot2 theme object that can be added to plots using the + operator.
#' @export
#'
#' @examples
#' library(ggplot2)
#'
#' # Basic usage
#' ggplot(mtcars, aes(x = mpg, y = hp)) +
#'   geom_point() +
#'   getCraGgTheme()
#'
#' # With custom parameters
#' ggplot(mtcars, aes(x = factor(cyl), y = mpg)) +
#'   geom_boxplot() +
#'   getCraGgTheme(base.size = 12, legend.position = "right")
#'
#' # With axis titles enabled
#' ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) +
#'   geom_point() +
#'   labs(x = "Miles per Gallon", y = "Horsepower", color = "Cylinders") +
#'   getCraGgTheme(axis.titles = TRUE)
#'
#' # Without grid lines for cleaner look
#' ggplot(mtcars, aes(x = factor(cyl), fill = factor(cyl))) +
#'   geom_bar() +
#'   getCraGgTheme(grid.lines = FALSE, legend.position = "none")
getCraGgTheme <- function(base.size = 11, base.family = "", legend.position = "bottom",
grid.lines = TRUE, axis.titles = FALSE) {
# Input validation
if (!is.numeric(base.size) || length(base.size) != 1 || base.size <= 0) {
stop("Argument 'base.size' must be a single positive number")
}
if (!is.character(base.family) || length(base.family) != 1) {
stop("Argument 'base.family' must be a single character string")
}
valid.positions <- c("bottom", "top", "left", "right", "none")
if (!legend.position %in% valid.positions) {
stop("Argument 'legend.position' must be one of: ", paste(valid.positions, collapse = ", "))
}
if (!is.logical(grid.lines) || length(grid.lines) != 1) {
stop("Argument 'grid.lines' must be a single logical value")
}
if (!is.logical(axis.titles) || length(axis.titles) != 1) {
stop("Argument 'axis.titles' must be a single logical value")
}
# Base theme
base.theme <- theme_minimal(base_size = base.size, base_family = base.family)
# Custom theme elements
custom.theme <- theme(
# Legend styling
legend.position = legend.position,
legend.key.size = unit(0.4, "cm"),
legend.key.width = unit(0.5, "cm"),
legend.spacing.x = unit(0.2, "cm"),
legend.spacing.y = unit(0.1, "cm"),
legend.margin = margin(t = 0.3, unit = "cm"),
legend.title = element_text(size = rel(0.9), face = "bold"),
legend.text = element_text(size = rel(0.8)),
# Axis styling
axis.title = if (axis.titles) element_text(size = rel(0.9), face = "bold") else element_blank(),
axis.text = element_text(size = rel(0.8), color = "grey30"),
axis.ticks = element_line(color = "grey80", linewidth = 0.3),
axis.ticks.length = unit(0.15, "cm"),
# Panel styling
panel.border = element_rect(color = "grey90", fill = NA, linewidth = 0.5),
panel.grid.major = if (grid.lines) element_line(color = "grey95", linewidth = 0.3) else element_blank(),
panel.grid.minor = if (grid.lines) element_line(color = "grey98", linewidth = 0.2) else element_blank(),
# Plot styling
plot.title = element_text(size = rel(1.2), face = "bold", hjust = 0,
margin = margin(b = 0.5, unit = "cm")),
plot.subtitle = element_text(size = rel(1.0), color = "grey40", hjust = 0,
margin = margin(b = 0.3, unit = "cm")),
plot.caption = element_text(size = rel(0.7), color = "grey50", hjust = 1,
margin = margin(t = 0.3, unit = "cm")),
plot.margin = margin(t = 0.5, r = 0.5, b = 0.5, l = 0.5, unit = "cm"),
# Strip text for faceted plots
strip.text = element_text(size = rel(0.9), face = "bold",
margin = margin(0.3, 0.3, 0.3, 0.3, unit = "cm")),
strip.background = element_rect(fill = "grey95", color = "grey90", linewidth = 0.3)
)
return(base.theme + custom.theme)
}
ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) +
geom_point() +
getCraGgTheme() +
getCraColors("discrete")
#' Apply CRA Color Scales
#'
#' This function provides adaptive color scales that work well with the CRA theme.
#' It automatically selects appropriate color palettes based on the number of categories
#' or provides sensible defaults for continuous scales.
#'
#' @param type Type of scale: "discrete" for categorical data, "continuous" for continuous data,
#'   or "both" to return both discrete and continuous scales (default: "both").
#' @param palette.discrete Color palette for discrete/categorical data. Options include:
#'   "cra" (custom CRA colors), "viridis", "plasma", "Set2", "Dark2" (default: "cra").
#' @param palette.continuous Color palette for continuous data. Options include:
#'   "viridis", "plasma", "cividis", "blues", "reds" (default: "viridis").
#' @param direction Direction of the color scale: 1 for normal, -1 for reversed (default: 1).
#'
#' @return A list of ggplot2 scale functions that can be added to plots.
#' @export
#'
#' @examples
#' library(ggplot2)
#'
#' # Discrete colors with default CRA palette
#' ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) +
#'   geom_point() +
#'   getCraGgTheme() +
#'   getCraColors("discrete")
#'
#' # Continuous colors
#' ggplot(mtcars, aes(x = mpg, y = hp, color = disp)) +
#'   geom_point() +
#'   getCraGgTheme() +
#'   getCraColors("continuous")
#'
#' # Both discrete and continuous (for plots with multiple aesthetics)
#' ggplot(mtcars, aes(x = factor(cyl), y = mpg, fill = factor(cyl))) +
#'   geom_boxplot(aes(alpha = disp)) +
#'   getCraGgTheme() +
#'   getCraColors("both")
getCraColors <- function(type = "both", palette.discrete = "cra", palette.continuous = "viridis", direction = 1) {
# Input validation
valid.types <- c("discrete", "continuous", "both")
if (!type %in% valid.types) {
stop("Argument 'type' must be one of: ", paste(valid.types, collapse = ", "))
}
valid.discrete <- c("cra", "viridis", "plasma", "Set2", "Dark2")
if (!palette.discrete %in% valid.discrete) {
stop("Argument 'palette.discrete' must be one of: ", paste(valid.discrete, collapse = ", "))
}
valid.continuous <- c("viridis", "plasma", "cividis", "blues", "reds")
if (!palette.continuous %in% valid.continuous) {
stop("Argument 'palette.continuous' must be one of: ", paste(valid.continuous, collapse = ", "))
}
if (!direction %in% c(1, -1)) {
stop("Argument 'direction' must be 1 or -1")
}
# Define custom CRA color palette
cra.colors <- c(
"#2E86AB",  # Blue
"#A23B72",  # Magenta
"#F18F01",  # Orange
"#C73E1D",  # Red
"#7209B7",  # Purple
"#277F8E",  # Teal
"#4B8B3B",  # Green
"#D4A574",  # Tan
"#85182A",  # Dark Red
"#3D315B"   # Dark Purple
)
# Create scale lists
scales <- list()
if (type %in% c("discrete", "both")) {
if (palette.discrete == "cra") {
scales <- append(scales, list(
scale_color_manual(values = cra.colors),
scale_fill_manual(values = cra.colors)
))
} else if (palette.discrete %in% c("Set2", "Dark2")) {
scales <- append(scales, list(
scale_color_brewer(type = "qual", palette = palette.discrete, direction = direction),
scale_fill_brewer(type = "qual", palette = palette.discrete, direction = direction)
))
} else {
scales <- append(scales, list(
scale_color_viridis_d(option = palette.discrete, direction = direction),
scale_fill_viridis_d(option = palette.discrete, direction = direction)
))
}
}
if (type %in% c("continuous", "both")) {
if (palette.continuous == "blues") {
scales <- append(scales, list(
scale_color_gradient(low = "#EFF3FF", high = "#08519C"),
scale_fill_gradient(low = "#EFF3FF", high = "#08519C")
))
} else if (palette.continuous == "reds") {
scales <- append(scales, list(
scale_color_gradient(low = "#FEE5D9", high = "#A50F15"),
scale_fill_gradient(low = "#FEE5D9", high = "#A50F15")
))
} else {
scales <- append(scales, list(
scale_color_viridis_c(option = palette.continuous, direction = direction),
scale_fill_viridis_c(option = palette.continuous, direction = direction)
))
}
}
return(scales)
}
ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) +
geom_point() +
getCraGgTheme() +
getCraColors("discrete")
#' df <- data.frame(
#'   group = rep(c("A", "B", "C"), each = 10),
#'   var1  = c(rnorm(10), rep(NA, 10), rnorm(10)),
#'   var2  = c(rnorm(5), rep(NA, 20), rnorm(5))
#' )
#'
#' # 2) Plot missing‐value proportions by group
#' getGroupedNaPlot(df, "group", viridis.pal = "C")
#'
#' @export
getGroupedNaPlot <- function(data, group.var, viridis.pal = "B") {
## Input data checks
if (!is.data.frame(data)) {
stop("`data` must be a data.frame.")
}
if (!is.character(group.var) || length(group.var) != 1) {
stop("`group.var` must be a single character string.")
}
if (!group.var %in% names(data)) {
stop(sprintf("Column '%s' not found in `data`.", group.var))
}
valid.pals <- toupper(LETTERS[1:8])
if (!toupper(viridis.pal) %in% valid.pals) {
stop("`viridis.pal` must be one of 'A' through 'H'.")
}
## Prepare grouping symbol and ensure factor for consistent ordering
group.sym <- rlang::sym(group.var)
data <- data |>
dplyr::mutate(
!!group.sym := as.factor(!!group.sym)
)
## Compute share of missing values by group
na.share.df <- data |>
dplyr::group_by(!!group.sym) |>
dplyr::summarise(
dplyr::across(
.cols  = dplyr::everything(),
.fns   = function(x) { sum(is.na(x)) / length(x) },
.names = "{col}"
),
.groups = "drop"
) |>
tidyr::pivot_longer(
cols      = -!!group.sym,
names_to  = "variable",
values_to = "share_missing"
)
## Build the heatmap
plot.obj <- ggplot2::ggplot(na.share.df,
ggplot2::aes(
x    = !!group.sym,
y    = variable,
fill = share_missing
)
) +
ggplot2::geom_tile(alpha = 0.9) +
ggplot2::scale_fill_gradientn(
colors = scales::viridis_pal(option = toupper(viridis.pal))(10),
name   = "Share missing",
limits = c(0, 1)
) +
ggplot2::theme_classic() +
ggplot2::theme(
axis.text.x  = ggplot2::element_text(angle = 90),
axis.ticks.x = ggplot2::element_blank()
) +
ggplot2::labs(
x = group.var,
y = "Variable"
)
return(plot.obj)
}
df <- data.frame(
group = rep(c("A", "B", "C"), each = 10),
var1  = c(rnorm(10), rep(NA, 10), rnorm(10)),
var2  = c(rnorm(5), rep(NA, 20), rnorm(5))
)
# 2) Plot missing‐value proportions by group
getGroupedNaPlot(df, "group", viridis.pal = "C")
# 2) Plot missing‐value proportions by group
getGroupedNaPlot(df, "group", viridis.pal = "A")
# 2) Plot missing‐value proportions by group
getGroupedNaPlot(df, "group", viridis.pal = "F")
# 2) Plot missing‐value proportions by group
getGroupedNaPlot(df, "group", viridis.pal = "F") +
getCraGgTheme()
devtools::check()
install.packages("pkgbuild")
install.packages("pkgbuild")
devtools::check()
devtools::document()
rm(list = ls())
devtools::document()
devtools::document()
